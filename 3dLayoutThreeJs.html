<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
            canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <div id="controls"  >
        <input type="button" id="add_client" value="Add client" />
        </div>


		<script src="js/three.min.js"></script>
          <script src="js/jquery-2.1.1.min.js"></script>

        <script>


            var camera, scene, renderer;
            var floor;


            init();
            animate();

            function init() {

                renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
                renderer.autoClear = false;
                //renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( new THREE.Color(0.19, 0.62, 0.8));
                document.body.appendChild( renderer.domElement );

                //

                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 20 );
                camera.position.set(-2, 0, 1);
                camera.up.set(0, 0, 1);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // var controls = new THREE.TrackballControls( camera );
                // controls.addEventListener( 'change', render );

                scene = new THREE.Scene();


                // AxisHelper
                var axisHelper = new THREE.AxisHelper(2);
                scene.add(axisHelper);


                // Floor
                var materialFloor = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.VertexColors, transparent: true, opacity: 0.85 } );

                var radius = 20;
                var segments = 30;

                var circleGeometry = new THREE.CircleGeometry( radius, segments );
                for ( var i = 0; i < circleGeometry.faces.length; i++ )
                {
                    face  = circleGeometry.faces[ i ];
                    face.vertexColors[ 0 ] = new THREE.Color();
                    face.vertexColors[ 0 ].setRGB(0.05, 0.30, 0.43);
                    face.vertexColors[ 1 ] = new THREE.Color();
                    face.vertexColors[ 1 ].setRGB(0.05, 0.30, 0.43);
                    face.vertexColors[ 2 ] = new THREE.Color();
                    face.vertexColors[ 2 ].setRGB(0.35, 0.69, 0.83);
                }

                floor = new THREE.Mesh( circleGeometry, materialFloor );

                scene.add( floor );


                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                scene.remove(floor);
                // Invert z for all objects
                for (var i = 0; i < scene.children.length; i++) {
                    var myobj = scene.children[i];
                    myobj.updateMatrix();
                    var mym = myobj.matrix;
                    var scalem = new THREE.Matrix4();
                    scalem.scale(new THREE.Vector3(1,1,-1));
                    myobj.matrix = scalem.multiply(mym);
                    myobj.matrixAutoUpdate = false;

                }


                renderer.clear();
                renderer.render( scene, camera );
                for (var i = 0; i < scene.children.length; i++) {
                    var myobj = scene.children[i];
                    myobj.matrixAutoUpdate = true;
                }
                scene.add(floor);

                renderer.autoclear = false;
                renderer.render( scene, camera );


            }

            var width = 2.0;  // The one in makePlane
            var videoAspectRatio = 4.0/3.0;
            var radius = 1.0;
            var totalArc = Math.PI ;
            var numParticipantsX = 3;  // We will be stacking up


            // Same orientation as regular XY axis: origin in left bottom corner
            function matrixForLayout(x, y) {
                var matrix = new THREE.Matrix4();

                var length = radius * Math.sqrt(2 - 2 * Math.cos(totalArc / numParticipantsX));


                // Y coordinate
                matrix.multiply(new THREE.Matrix4().makeTranslation(0, 0, y * 1.05 * length  / videoAspectRatio));

                // X coordinate
                matrix.multiply(new THREE.Matrix4().makeRotationZ((totalArc / numParticipantsX) / 2 - totalArc / 2));
                matrix.multiply(new THREE.Matrix4().makeRotationZ(x * totalArc / numParticipantsX));
                matrix.multiply(new THREE.Matrix4().makeTranslation(radius, 0.0, 0.0)); // Same for all
                matrix.multiply(new THREE.Matrix4().makeRotationY(-Math.PI / 2)); // Original geometry is xy plane. Make it yz plane
                matrix.multiply(new THREE.Matrix4().makeScale((length / width) / videoAspectRatio, length / width, 1.0)); // Adapt width to fit arc
                matrix.multiply(new THREE.Matrix4().makeScale(2,2,1));
                matrix.multiply(new THREE.Matrix4().makeTranslation( 0.5, 0, 0));  // original bounding box is (-0.5,-0.5)->(0.5,0.5).

                return matrix;
            }

            function rearrangeClients() {
                var posClient = 0;
                // rearrange layout
                for (var i = 0; i < scene.children.length; i++) {
                    var myobj = scene.children[i];
                    if (myobj.myType === "client") {

                        // reset previous position and rotation
                        myobj.position.set(0,0,0);
                        myobj.rotation.set(0,0,0);
                        myobj.scale.set(1,1,1);
                        myobj.updateMatrix();
                        myobj.applyMatrix(matrixForLayout(posClient % numParticipantsX, Math.floor(posClient / numParticipantsX)));
                        posClient++;
                    }
                }
            }

            function addClient(id) {
                var mesh;
                var geometry = new THREE.PlaneGeometry( 1, 1, 1 );
                var texture = THREE.ImageUtils.loadTexture( 'texture.png' );
                texture.anisotropy = renderer.getMaxAnisotropy();
                var material = new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } );
                mesh = new THREE.Mesh( geometry, material );
                mesh.myType = "client";
                mesh.name = id;
                scene.add( mesh );
                rearrangeClients();
            }

            function removeClient(id) {
                var obj = scene.getObjectByName( id );
                scene.remove(obj);
                rearrangeClients();
            }

            var nextId = 0;
            $("#add_client").click(function () {
                addClient(nextId);

                // Debug: add button to remove client
                var myId = nextId;
                var myButton =$('<input type="button" value="Remove ' + myId + '"/>');
                myButton.click(function() {
                    console.log("Remmoving client " + myId);
                    removeClient(myId);
                    $(this).remove();

                });
                $('#controls').append(myButton);
                nextId++;
            });

        </script>

    </body>
</html>
